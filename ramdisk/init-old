#!/bin/sh
# /init — Minimal initramfs for msm8916 Samsung A5
# Modules logic (NEW):
#   - mount modules partition at /modules_src
#   - copy /modules_src/lib/modules/$(uname -r) -> /sysroot/lib/modules/$(uname -r)
# Firmware logic:
#   - mount firmware partition at /firmware_src
#   - copy missing files only into /sysroot/lib/firmware (no overwrite)
#
# Root selection:
#   - tries mmcblk1p1, mmcblk1p2, mmcblk0p27

set -eu

# ---- partitions (adjust if they change) ----
root_part_1=mmcblk1p1
root_part_2=mmcblk1p2
root_part_3=mmcblk0p27
modules_part=mmcblk0p25
firmware_part=mmcblk0p26

wait_secs=12

export PATH=/bin:/sbin:/usr/bin:/usr/sbin

# busybox applets
/bin/busybox --install -s 2>/dev/null || true

log(){ echo "[initrd] $*" > /dev/kmsg 2>/dev/null || echo "[initrd] $*"; }
drop_shell(){ log "Dropping to shell"; exec /bin/sh; }

# Copy files/dirs from src -> dst ONLY if they do not already exist in dst
copy_missing_tree() {
  src="$1"
  dst="$2"
  [ -d "$src" ] || return 0
  mkdir -p "$dst"

  (cd "$src" && find . -mindepth 1 -print) | while read -r rel; do
    [ "$rel" = "." ] && continue
    if [ ! -e "$dst/$rel" ]; then
      mkdir -p "$(dirname "$dst/$rel")" 2>/dev/null || true
      cp -a "$src/$rel" "$dst/$rel" 2>/dev/null || true
    fi
  done
}

# Copy a directory recursively, overwriting destination (modules must match kernel)
# We intentionally overwrite the specific kver dir, not the whole /lib/modules
copy_dir_replace() {
  src="$1"
  dst="$2"
  [ -d "$src" ] || return 1
  rm -rf "$dst" 2>/dev/null || true
  mkdir -p "$(dirname "$dst")" 2>/dev/null || true
  cp -a "$src" "$dst" 2>/dev/null || return 1
  return 0
}

# ---- mounts ----
mkdir -p /proc /sys /dev /run /sysroot
mount -t proc  proc  /proc
mount -t sysfs sysfs /sys

# devtmpfs should give you /dev/mmcblk* without mdev
mount -t devtmpfs devtmpfs /dev || true

# optional (harmless)
mkdir -p /dev/pts
mount -t devpts devpts /dev/pts 2>/dev/null || true

# ---- wait for a block device ----
wait_for_dev() {
  dev="/dev/$1"
  i=0
  while [ $i -lt "$wait_secs" ]; do
    [ -b "$dev" ] && return 0
    sleep 1
    i=$((i+1))
  done
  return 1
}

# ---- try mount root candidate ----
try_root() {
  part="$1"
  dev="/dev/$part"

  if ! wait_for_dev "$part"; then
    log "No device: $dev"
    return 1
  fi

  log "Mount root: $dev -> /sysroot"
  umount /sysroot 2>/dev/null || true
  mount -t ext4 -o rw "$dev" /sysroot 2>/dev/null || return 1

  # minimal sanity: rootfs must have /usr
  if [ -d /sysroot/usr ]; then
    return 0
  fi

  log "Not a rootfs: $dev"
  umount /sysroot 2>/dev/null || true
  return 1
}

# ---- optional: force backlight/LED brightness early ----
log "Forcing backlight/LED brightness…"

if [ -d /sys/class/backlight ]; then
  for b in /sys/class/backlight/*/brightness; do
    [ -e "$b" ] || continue
    max="${b%/brightness}/max_brightness"
    if [ -r "$max" ]; then
      v="$(cat "$max" 2>/dev/null || echo 255)"
      echo "$v" > "$b" 2>/dev/null || true
      log "backlight $(basename "$(dirname "$b")") -> $v"
    else
      echo 255 > "$b" 2>/dev/null || true
      log "backlight $(basename "$(dirname "$b")") -> 255"
    fi
  done
else
  log "No /sys/class/backlight"
fi

if [ -d /sys/class/leds ]; then
  for l in /sys/class/leds/*/brightness; do
    [ -e "$l" ] || continue
    max="${l%/brightness}/max_brightness"
    if [ -r "$max" ]; then
      v="$(cat "$max" 2>/dev/null || echo 255)"
      echo "$v" > "$l" 2>/dev/null || true
    else
      echo 255 > "$l" 2>/dev/null || true
    fi
  done
else
  log "No /sys/class/leds"
fi

# ---- select root ----
log "Waiting for storage…"
wait_for_dev "$root_part_1" || true
wait_for_dev "$root_part_2" || true
wait_for_dev "$root_part_3" || true

if try_root "$root_part_1"; then
  log "Root selected: /dev/$root_part_1"
elif try_root "$root_part_2"; then
  log "Root selected: /dev/$root_part_2"
elif try_root "$root_part_3"; then
  log "Root selected: /dev/$root_part_3"
else
  log "Partitions seen:"
  cat /proc/partitions 2>/dev/null || true
  drop_shell
fi

# ---- modules + firmware into root ----
mkdir -p /sysroot/lib/modules /sysroot/lib/firmware

wait_for_dev "$modules_part"  || { log "Missing modules dev /dev/$modules_part"; drop_shell; }
wait_for_dev "$firmware_part" || { log "Missing firmware dev /dev/$firmware_part"; drop_shell; }

# ---------- MODULES (copy kver dir) ----------
kver="$(uname -r 2>/dev/null || echo unknown)"
log "Kernel release (uname -r): $kver"

mkdir -p /modules_src
log "Mount modules src: /dev/$modules_part -> /modules_src"
mount -t ext4 -o ro "/dev/$modules_part" /modules_src || drop_shell

src_kver_dir="/modules_src/lib/modules/$kver"
dst_kver_dir="/sysroot/lib/modules/$kver"

if [ ! -d "$src_kver_dir" ]; then
  log "Expected modules dir not found: $src_kver_dir"
  log "Available under /modules_src/lib/modules:"
  ls -la /modules_src/lib/modules 2>/dev/null || true
  drop_shell
fi

log "Copying modules: $src_kver_dir -> $dst_kver_dir (replace)"
copy_dir_replace "$src_kver_dir" "$dst_kver_dir" || drop_shell

# keep it tidy (optional)
umount /modules_src 2>/dev/null || true
rmdir /modules_src 2>/dev/null || true

# ---------- FIRMWARE (copy missing only) ----------
mkdir -p /firmware_src
log "Mount firmware src: /dev/$firmware_part -> /firmware_src"
mount -t ext4 -o ro "/dev/$firmware_part" /firmware_src || drop_shell

log "Merging missing firmware into /sysroot/lib/firmware (no overwrite)"
copy_missing_tree /firmware_src /sysroot/lib/firmware

umount /firmware_src 2>/dev/null || true
rmdir /firmware_src 2>/dev/null || true

# optional: expose them under initramfs too
mkdir -p /lib
ln -snf /sysroot/lib/modules /lib/modules
ln -snf /sysroot/lib/firmware /lib/firmware

# ---- switch_root ----
log "switch_root -> /sbin/init"
umount /proc 2>/dev/null || true
umount /sys 2>/dev/null || true
umount /dev/pts 2>/dev/null || true

exec switch_root /sysroot /sbin/init || drop_shell
